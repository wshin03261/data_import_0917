---
title: "Data_manipulation_0919"
output: github_document
date: "2024-09-18"
---

tidyverse will also load dplyr

Impoer the two data sets that we're going to manipulate.

```{r message=FALSE, echo= FALSE}
library(tidyverse)
options(tibble.print_min = 3)
litters_df = 
    read_csv("FAS_litters.csv", na = c("NA", ".", ""))
litters_df = 
    janitor::clean_names(litters_df)
pups_df = 
    read_csv("FAS_pups.csv", na = c("NA", ".", ""))
pups_df = 
    janitor::clean_names(pups_df)
```

##select

You can specify the columns you want to keep by naming all of them:
select()

```{r}
select(litters_df, group, litter_number, gd0_weight)
```

You can specify the specify a range of columns to keep:
so column 1 ~ until gd18_weight

```{r}
select(litters_df, group:gd18_weight)
```

You can also specify columns you’d like to remove:
remove from the end until gd18_weight. 

```{r}
select(litters_df, -(group:gd18_weight))
```

you can also have a keyword selected

```{r}
select(litters_df, starts_with("gd"))

select(litters_df, contains("pups"))
```


You can rename variables as part of this process:

group to GROUP

```{r}
select(litters_df, GROUP = group, LiTtEr_NuMbEr = litter_number)

rename(litters_df, GROUP = group)


```

If all you want to do is rename something, you can use `rename` instead of `select`. This will rename the variables you care about, and keep everything else:

```{r}
rename(litters_df, GROUP = group, LiTtEr_NuMbEr = litter_number)
```

There are some handy helper functions for select; read about all of them using ?select_helpers. I use starts_with(), ends_with(), and contains() often, especially when there variables are named with suffixes or other standard patterns:

```{r}
select(litters_df, starts_with("gd"))
```

I also frequently use is everything(), which is handy for reorganizing columns without discarding anything:
```{r}
select(litters_df, litter_number, pups_survive, everything())
```

relocate does a similar thing (and is sort of like rename in that it’s handy but not critical):
```{r}
relocate(litters_df, litter_number, pups_survive)
```

In larger datasets,

Lastly, like other functions in dplyr, select will export a dataframe even if you only select one column. Mostly this is fine, but sometimes you want the vector stored in the column. To pull a single variable, use pull.

##Learning assessment

In the pups data, select the columns containing litter number, sex, and PD ears.
```{r}
select(pups_df, litter_number, sex, pd_ears)
```

##filter

You will often filter using comparison operators (>, >=, <, <=, ==, and !=). You may also use %in% to detect if values appear in a set, and is.na() to find missing values. The results of comparisons are logical – the statement is TRUE or FALSE depending on the values you compare – and can be combined with other comparisons using the logical operators & and |, or negated using !.

Some ways you might filter the litters data are:

gd_of_birth == 20
pups_born_alive >= 2
pups_survive != 4
!(pups_survive == 4)
group %in% c("Con7", "Con8")
group == "Con7" & gd_of_birth == 20

```{r}
filter(litters_df, gd_of_birth == 20)
filter(litters_df, gd_of_birth == 19)
```

```{r}
filter(litters_df, pups_born_alive > 8)
filter(litters_df, pups_born_alive >=8)
```

```{r}
filter(litters_df,pups_born_alive !=9) #not equal
```

```{r}
filter(litters_df, group == "Low8")
filter(litters_df, group %in% c("Low7","Low8"))
```

```{r}
filter(litters_df, group %in% c("Low7","Low8"), pups_born_alive == 8)
```

filter missing variables

```{r}
drop_na(litters_df)

drop_na(litters_df, gd0_weight) #drop missing values in gd0_weight
```

A very common filtering step requires you to omit missing observations. You can do this with filter, but I recommend using drop_na from the tidyr package:

drop_na(litters_df) will remove any row with a missing value
drop_na(litters_df, wt_increase) will remove rows for which wt_increase is missing.

##Learning Assessment2
In the pups data:

1.Filter to include only pups with sex 1
2.Filter to include only pups with PD walk less than 11 and sex 2

```{r}
filter(pups_df, sex == 1)
```

```{r}
filter(pups_df, sex == 2, pd_walk < 11)
```

##Mutate

Sometimes you need to select columns; sometimes you need to change them or create new ones. You can do this using mutate.

The example below creates a new variable measuring the difference between gd18_weight and gd0_weight and modifies the existing group variable.

```{r}
mutate(litters_df,
  wt_gain = gd18_weight - gd0_weight,
  group = str_to_lower(group)
)
# can do multiple things

mutate(litters_df, sq_pups = pups_born_alive^2)

```

A few things in this example are worth noting:

Your new variables can be functions of old variables
New variables appear at the end of the dataset in the order that they are created
You can overwrite old variables
You can create a new variable and immediately refer to (or change) it
Creating a new variable that does exactly what you need can be a challenge; the more functions you know about, the easier this gets.

##Learning Assessment3
In the pups data:

1.Create a variable that subtracts 7 from PD pivot
2.Create a variable that is the sum of all the PD variables

```{r}
mutate(pups_df, pivot_minus7 = pd_pivot - 7)
```

```{r}
mutate(pups_df, pd_sum = pd_ears + pd_eyes + pd_pivot + pd_walk)
```

## arrange

In comparison to the preceding, arranging is pretty straightforward. You can arrange the rows in your data according to the values in one or more columns:

```{r}
arrange(litters_df, gd0_weight)

arrange(litters_df, desc(gd0_weight)) #descending order

arrange(litters_df, pups_born_alive, gd0_weight) 
#order pups born alive first, then gd0_weight 
```


```{r}
head(arrange(litters_df, group, pups_born_alive), 10)
```


##Piping

We’ve seen several commands you will use regularly for data manipulation and cleaning. You will rarely use them in isolation. For example, suppose you want to load the data, clean the column names, remove pups_survive, and create wt_gain. There are a couple of options for this kind of multi-step data manipulation:

1.define intermediate datasets (or overwrite data at each stage)
2.nest function calls
The following is an example of the first option:

```{r}
litters_df_raw = 
    read_csv("FAS_litters.csv", na = c("NA", ".", ""))

litters_df_clean_names = janitor::clean_names(litters_df_raw)

litters_df_selected_cols = select(litters_df_clean_names, -pups_survive)

litters_df_with_vars = 
  mutate(
    litters_df_selected_cols, 
    wt_gain = gd18_weight - gd0_weight,
    group = str_to_lower(group))

litters_df_with_vars_without_missing = 
  drop_na(litters_df_with_vars, wt_gain)

litters_df_with_vars_without_missing
```

Below, we try the second option:

```{r}
litters_df_clean = 
  drop_na(
    mutate(
      select(
        janitor::clean_names(
          read_csv("FAS_litters.csv", na = c("NA", ".", ""))
          ), 
      -pups_survive
      ),
    wt_gain = gd18_weight - gd0_weight,
    group = str_to_lower(group)
    ),
  wt_gain
  )

litters_df_clean
```

These are both confusing and bad: the first gets confusing and clutters our workspace, and the second has to be read inside out.

Piping solves this problem. It allows you to turn the nested approach into a sequential chain by passing the result of one function call as an argument to the next function call:

```{r}
litters_df = 
  read_csv("FAS_litters.csv", na = c("NA", ".", "")) |> 
  janitor::clean_names() |> 
  select(-pups_survive) |> 
  mutate(
    wt_gain = gd18_weight - gd0_weight,
    group = str_to_lower(group)) |> 
  drop_na(wt_gain)

litters_df
```

The functions in dplyr (and much of the tidyverse) are designed to work smoothly with the pipe operator. By default, the pipe will take the result of one function call and use that as the first argument of the next function call; by design, functions in dplyr will take a tibble as an input and return a tibble as a result. As a consequence, functions in dplyr are easy to connect in a data cleaning chain.

In the majority of cases (and everywhere in the tidyverse) you can trust that the first argument is the right one and be happy with life, but there are some cases where what you’re piping isn’t going into the first argument. Here, using the placeholder _ is necessary to indicate where the object being piped should go. For example, to regress wt_gain on pups_born_alive, you might use:

```{r}
litters_df |>
  lm(wt_gain ~ pups_born_alive, data = _) |>
  broom::tidy()
```


here are limitations to the pipe. You shouldn’t have sequences that are too long; there isn’t a great way to deal with multiple inputs and outputs; and not everyone will know what |> means or does. That said, compared to days when R users only had the first two options, life is much better!

##learning assessment4

Write a chain of commands that:

1.loads the pups data
2.cleans the variable names
3.filters the data to include only pups with sex 1
4.removes the PD ears variable
5.creates a variable that indicates whether PD pivot is 7 or more days

```{r}
pups_df = 
    read_csv("FAS_pups.csv", na = c("NA", ".")) |>
  janitor::clean_names() |> 
  filter(sex == 1) |> 
  select(-pd_ears) |> 
  mutate(pd_pivot_gt7 = pd_pivot > 7)

pups_df
```

